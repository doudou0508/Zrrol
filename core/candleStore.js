// 
// Low level datastore to persist 1m candles
// generated by the CandleManager to disk.
//
 
var zlib = require('zlib');
var fs = require('fs');
var lodash = require('lodash');
var async = require('async');
var _ = require('lodash');

var config = require('./util').getConfig();

var Day = function(day) {
    this.day = day;
    this.state = "uninitialized";
    this.candles = [];
}

Day.prototype.addCandles = function (candles) {
  this.candles = this.candles.concat(candles);    
};

var Store = function() {
  this.directory = config.history.directory;
  this.oldDay = null;
  this.day = null;
  // This is intented to be an array of arrays. 
  this.queue = [];
 
  //TODO(yin): Make this mockable, or mock the fs in tests.
  // write a daily database
  this.write = async.compose(
    this.writeFile,
    this.deflate,
    this.toCSV
  );
 
  // read a daily database
  this.read = async.compose(
    this.toArray,
    this.unzip,
    this.readFile
  );
}

Store.prototype.openDay = function(day, callback) {
    // Load only if the open day changed, or we never opened a day
    if (this.day == null || day != this.day.day) {
        var filename = filenameForDay(day);
        prepareNewDay();
        this.loadDay(function(err, candles) {
            if (!err) {
                this.day.addCandles(candles);
                this.day.state = 'open';
            }
            callback(err, candles);
        });
    }
}

Store.prototype.loadDay = function(day, callback) {
    var filename = filenameForDay(day);
    this.read(filename, function(err, candles) {
        callback(err, candles);
    });
}

Store.prototype.prepareNewDay = function(day) {
    if (this.day.state != 'loading') {
        // Do we need to keep 
        this.day.state = 'closing';
        this.day = new Day(day);
    }
}

// Queue's candles to be added as soon as a day is loaded
Store.prototype.addCandles = function(candles) {
    //NOTE: this.queue is array of arrays.
    this.queue.push(candles);
    this.flush();
}

// If there is a day in open state, append all queued candles to it.
Store.prototype.flush = function() {
    if (this.queue.length > 0 && this.day != null && this.day.state = 'open') {
        this.day.addCandles(_.flatten(this.queue));
        this.queue = [];
    }
}

Store.prototype.toCSV = function(file, candles, next) {
  var csv = _.map(candles, function(properties) {
      return _.values(properties).join(',');
  }).join('\n');
 
  next(null, file, csv);
}
 
Store.prototype.deflate = function(file, csv, next) {
  zlib.deflate(csv, function(err, buffer) {
    if(err)
      throw 'Unable to deflate CSV';
 
    next(null, file, buffer);
  });
}
 
Store.prototype.writeFile = function(file, gzip, next) {
  fs.writeFile(this.directory + file, gzip, function(err) {
    if(err)
      throw 'Unable to write CSV';
 
    next();
  });
}
 
Store.prototype.readFile = function(file, next) {
  fs.readFile(this.directory + file, function(err, buffer) {
    if(err)
      throw 'Unable to read CSV';
 
    next(null, buffer);
  });
}
 
Store.prototype.unzip = function(buffer, next) {
  zlib.unzip(buffer, function(err, buffer) {
    if(err)
      throw 'Unable to unzip CSV';
 
    next(null, buffer.toString());
  });
}
 
Store.prototype.toArray = function(csv, next) {
  var f = parseFloat;
  var i = parseInt;
  var obj = _.map(csv.toString().split('\n'), function(l) {
    l = l.split(',');
    return {
      s: i(l[0]),
      o: f(l[1]),
      h: f(l[2]),
      l: f(l[3]),
      c: f(l[4]),
      p: f(l[5])
    }
  });
 
  next(obj);
}

var filenameForDay = function(day) {
    //TODO(yin): Missing exchange and currency pair, filenames will conflict.
    return "history-" + day.toString() + "csv.z";
};

module.exports = Store;
